
(()=>{
  const $ = id => document.getElementById(id);
  const num = (v,d=0)=>{const n=Number(v);return isNaN(n)?d:n};
  const clamp=(x,lo,hi)=>Math.min(Math.max(x,lo),hi);
  const fmt=(v)=> (v==null||isNaN(v)?"":"$"+Math.round(v).toLocaleString());
  const fmtDate = (s)=>{const d=new Date(s); return isNaN(d)? "—" : d.toLocaleDateString(); };
  const monthKey=(dt)=>{const d=new Date(dt);if(isNaN(d))return null;return d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0");};
  let allowedPctByMonth = [0.04,0.04,0.07,0.09,0.11,0.12,0.12,0.11,0.09,0.07,0.06,0.08];

  
  // --- Export capture storage (split by panel) ---
  let __newPricingRows = [];             // [["Floorplan","Term (mo)","Price ($)"], ...] for New Pricing
  let __seasonalityNewRows = [];         // [["Month","Actual Expirations","Allowed Max"], ...] for New run

  let __renewalsRows = [];               // [["Unit","Floorplan","Lease End","Term (mo)","Offer ($)",...], ...] for Renewals
  let __seasonalityRenewRows = [];       // [["Month","Actual Expirations","Allowed Max"], ...] for Renew run
  // expose buffers to window for cross-module access
  window.__newPricingRows = __newPricingRows;
  window.__seasonalityNewRows = __seasonalityNewRows;
  window.__renewalsRows = __renewalsRows;
  window.__seasonalityRenewRows = __seasonalityRenewRows;

  function resetNewBuffers(){
    __newPricingRows = [["Floorplan","Starting Rent ($)","Term (mo)","Price ($)"]];
    __seasonalityNewRows = [["Month","Actual Expirations","Allowed Max"]];
    window.__newPricingRows = __newPricingRows;
    window.__seasonalityNewRows = __seasonalityNewRows;
  }
  function resetRenewBuffers(){
  __renewalsRows = [[
    "Unit","Floorplan","Lease End","Term (mo)",
    "Offer ($)","Current ($)","Starting Rent ($)","Baseline New ($)",
    "Pct-to-New","Guardrail Max",
    "BasePct","TermPremiumPct","FinalPctApplied","GuardrailsOn",
    "ShortTermPct","OverCapPct","SeasonalityPct"
  ]];
    __seasonalityRenewRows = [["Month","Actual Expirations","Allowed Max"]];
    window.__renewalsRows = __renewalsRows;
    window.__seasonalityRenewRows = __seasonalityRenewRows;
  }

  // Per-panel export buttons
  function enableExportNew(on){ const b=$("exportNew"); if(b) b.disabled=!on; }
  function enableExportRenew(on){ const b=$("exportRenew"); if(b) b.disabled=!on; }

  function exportNew(){
    if (__newPricingRows.length <= 1 || __seasonalityNewRows.length <= 1){
      alert("Run New first."); return;
    }
    const wb = XLSX.utils.book_new();
    const ws1 = XLSX.utils.aoa_to_sheet(__newPricingRows);
    const ws2 = XLSX.utils.aoa_to_sheet(__seasonalityNewRows);
    XLSX.utils.book_append_sheet(wb, ws1, "New Pricing");
    XLSX.utils.book_append_sheet(wb, ws2, "Seasonality");
    const fname = "export_new_" + new Date().toISOString().slice(0,19).replace(/[:T]/g,"-") + ".xlsx";
    XLSX.writeFile(wb, fname);
  }

  
  function setBadge(elId, kind, rows){
    const el = $(elId);
    if(!el) return;
    const ts = new Date();
    const stamp = ts.toLocaleString();
    const label = kind === "new" ? "New" : "Renew";
    const count = Math.max(0, rows|0);
    el.textContent = `Last run: ${label} • rows: ${count} • ${stamp}`;
    el.style.display = "block";
  }

  function exportRenew(){
    if (__renewalsRows.length <= 1 || __seasonalityRenewRows.length <= 1){
      alert("Run Renewals first."); return;
    }
    const wb = XLSX.utils.book_new();
    const ws1 = XLSX.utils.aoa_to_sheet(__renewalsRows);
    const ws2 = XLSX.utils.aoa_to_sheet(__seasonalityRenewRows);
    XLSX.utils.book_append_sheet(wb, ws1, "Renewals");
    XLSX.utils.book_append_sheet(wb, ws2, "Seasonality");
    const fname = "export_renew_" + new Date().toISOString().slice(0,19).replace(/[:T]/g,"-") + ".xlsx";
    XLSX.writeFile(wb, fname);
  }
  // (removed global click dispatcher to avoid double-trigger on export buttons)
  function enableExportBtn(){}
  function exportXLSX(){ alert("Use the panel-specific Export buttons."); }

  function enableExportNew(on){ const b=$("exportNew"); if(b) b.disabled=!on; }
  function enableExportRenew(on){ const b=$("exportRenew"); if(b) b.disabled=!on; }

  // Build renewal terms 2..24 months
  function buildRenTerms(){
    const el=$("renTermBox"); el.innerHTML="";
    for(let t=2;t<=24;t++){
      const id="ren_t_"+t;
      el.insertAdjacentHTML("beforeend",`
        <label style="display:flex;align-items:center;gap:6px;">
          <input type="checkbox" id="${id}" value="${t}" ${t<=14?'checked':''}>
          <span>${t}</span>
        </label>
      `);
    }
  }
  buildRenTerms();
  const readRenTerms = ()=> Array.from(document.querySelectorAll("#renTermBox input:checked")).map(x=>parseInt(x.value)).sort((a,b)=>a-b);

  // CSV mapping
  let rawRows=[], mapping=null, mappedRows=[];
  const targetFields = [
    {key:"UnitID", req:true,  hints:["unitid","unit","apt"]},
    {key:"Floorplan", req:true, hints:["floorplan","type","unittype","plan"]},
    {key:"Bedrooms", req:false, hints:["bedrooms","beds","br","bd","bed"]},
    {key:"Status", req:true, hints:["status","occupancy","occ"]},
    {key:"CurrentRent", req:true, hints:["currentrent","rent","base rent"]},
    {key:"LeaseEnd", req:false, hints:["leaseend","expiration","exp date","move out"]},
    {key:"PreleaseStart", req:false, hints:["prelease","future lease","future start"]},
    {key:"VacantDays", req:false, hints:["vacantdays","days vacant"]},
    {key:"MoveInDate", req:false, hints:["movein","lease start"]},
    {key:"AmenityAdj", req:false, hints:["amenity adj","premium","discount"]},
  ];
  const normalizeHeader=(s)=> String(s||"").toLowerCase().replace(/[^a-z0-9]/g,"");

  $("file").addEventListener("change",(e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    Papa.parse(f,{header:true,skipEmptyLines:true,complete:(r)=>{
      rawRows=r.data;
      const cols=Object.keys(rawRows[0]||{});
      mapping={};
      const lower = cols.map(c=>({orig:c, norm:normalizeHeader(c)}));
      for(const tf of targetFields){
        let best = lower.find(c=>c.norm===normalizeHeader(tf.key));
        if(!best) best = lower.find(c=>tf.hints.some(h=>c.norm===normalizeHeader(h)));
        mapping[tf.key] = best ? best.orig : "";
      }
      renderMappingTable(cols, mapping); $("automap").style.display="block"; validateMappingPreview();
    },error:(err)=>alert("Parse error: "+err.message)});
  });

  function renderMappingTable(cols, mapping){
    const opts = sel => ["",...cols].map(c=>`<option ${mapping[sel]===c?"selected":""}>${c}</option>`).join("");
    const rows = targetFields.map(tf=>`
      <tr><td>${tf.key}${tf.req?" *":""}</td>
      <td><select class="sel mapSel" data-key="${tf.key}">${opts(tf.key)}</select></td></tr>`).join("");
    $("mapTable").innerHTML = `<table class="basic"><thead><tr><th>Field</th><th>CSV Column</th></tr></thead><tbody>${rows}</tbody></table>`;
    document.querySelectorAll(".mapSel").forEach(el=> el.addEventListener("change",()=>{mapping[el.dataset.key]=el.value; validateMappingPreview();}));
  }
  function validateMappingPreview(){
    const reqMissing = targetFields.filter(tf=>tf.req && !mapping[tf.key]);
    $("validationBox").textContent = reqMissing.length ? `Missing required: ${reqMissing.map(x=>x.key).join(", ")}` : "Looks good.";
    return !reqMissing.length;
  }

  $("confirmMapping").onclick=()=>{
    if(!validateMappingPreview()){ alert("Fix required fields first."); return; }
    mappedRows = rawRows.map(r=>({
      UnitID:       mapping.UnitID       ? r[mapping.UnitID]       : "",
      Floorplan:    mapping.Floorplan    ? r[mapping.Floorplan]    : "",
      Bedrooms:     mapping.Bedrooms     ? Number(r[mapping.Bedrooms]) : NaN,
      Status:       (mapping.Status      ? String(r[mapping.Status]) : "").toLowerCase(),
      CurrentRent:  mapping.CurrentRent  ? Number(r[mapping.CurrentRent]) : NaN,
      LeaseEnd:     mapping.LeaseEnd     ? r[mapping.LeaseEnd]     : "",
      PreleaseStart:mapping.PreleaseStart? r[mapping.PreleaseStart]: "",
      VacantDays:   mapping.VacantDays   ? Number(r[mapping.VacantDays]) : 0,
      MoveInDate:   mapping.MoveInDate   ? r[mapping.MoveInDate]   : "",
      AmenityAdj:   mapping.AmenityAdj   ? Number(r[mapping.AmenityAdj]) : 0
    }));
    alert("Mapping confirmed. Use Run New or Run Renewals to generate results."); window.mappedRows = mappedRows;
    try{ if (typeof window.setHasUpload==='function') window.setHasUpload(); }catch(e){}
    try{
      const rows=(window.propertySetup&&window.propertySetup.floorplans)||[];
      if (!rows.length) prefillFromRentRoll(); else mergeFromRentRoll();
      if (typeof window.renderFPMapCard==='function') window.renderFPMapCard();
      if (typeof window.autoMapFromSettings==='function') window.autoMapFromSettings();
      if (typeof window.__applyLockState==='function') window.__applyLockState();
    }catch(e){}

    (function(){
      function statusStr(s){ return String(s||"").toLowerCase(); }
      function isVacant(s){ s=statusStr(s); return s.includes("vacant"); }
      function isNotice(s){ s=statusStr(s); return s.includes("notice"); }
      function isOccLike(s){ s=statusStr(s); return s.startsWith("occupied") || s.includes("notice"); }

      function calcTrending(rows){
        const N = rows.length;
        let vac=0, notices=0, preRaw=0, occ=0;
        for(const r of rows){
          const s = statusStr(r.Status);
          if (isVacant(s)) vac++;
          if (isNotice(s)) notices++;
          if (isOccLike(s)) occ++;
          if (r.PreleaseStart) preRaw++;
        }
        const pre = Math.min(preRaw, vac + notices);
        const todayOcc = N ? (occ / N) : 0;
        const trending = N ? ((occ + pre - notices) / N) : 0;
        return { todayOcc, trending: Math.max(0, Math.min(1, trending)), total: N, occ, notices, pre };
      }

      function calcStrugglingFPs(rows, targetOcc){
        const by = new Map();
        for(const r of rows){
          const fp = r.Floorplan || "(unknown)";
          if (!by.has(fp)) by.set(fp, []);
          by.get(fp).push(r);
        }
        const out=[];
        for (const [fp, list] of by.entries()){
          const t = calcTrending(list).trending;
          if (t < targetOcc) out.push({ code: fp, trendingOcc: t });
        }
        out.sort((a,b)=> (a.trendingOcc - b.trendingOcc));
        return out;
      }

      function calcStale(rows){
        const list = rows.filter(r => (Number(r.VacantDays)||0) >= 30 && isVacant(r.Status));
        list.sort((a,b)=> (Number(b.VacantDays)||0) - (Number(a.VacantDays)||0));
        return list.map(r => ({
          unit: r.UnitID || r.Unit || "—",
          fp: r.Floorplan || "",
          days: Number(r.VacantDays)||0,
          fpPrice: r.Price || r.NewPrice || null,
          hasPre: !!r.PreleaseStart
        }));
      }

      function calcExpiring(rows){
        const in30 = new Date(); in30.setDate(in30.getDate()+30);
        let exp=0;
        for(const r of rows){
          if(!r.LeaseEnd) continue;
          const d = new Date(r.LeaseEnd);
          if(!isNaN(d) && d <= in30) exp++;
        }
        return { expiring30d: exp, undecided30d: exp };
      }

      function updateWidgetData(rows){
        const cfg = (typeof readCfg==='function') ? readCfg() : { comfortTarget: 0.95 };
        const t = calcTrending(rows);
        const exp = calcExpiring(rows);
        const stale = calcStale(rows);
        const fps = calcStrugglingFPs(rows, cfg.comfortTarget || 0.95);

        window.totalUnits = t.total;
        window.occupiedNow = t.occ;
        window.onNotice = t.notices;
        window.preleased = t.pre;

        window.todayOcc = t.todayOcc;
        window.undecidedRenewals30d = exp.undecided30d;
        window.expiring30d = exp.expiring30d;
        window.approvals7d = window.approvals7d || 0;
        window.strugglingFPs = fps;
        window.staleUnits30d = stale;

        if (typeof repaintStatus45 === 'function') repaintStatus45();
      }

      window.__updateStatusFromMappedRows = updateWidgetData;
    })();

    // Call it immediately after mapping confirmation
    if (Array.isArray(window.mappedRows)) { window.__updateStatusFromMappedRows(window.mappedRows); }
  };

  // Seasonality chart + over-cap calc
  let seasonChart, overByKey={};
  function renderSeasonality(norm, rowsTarget){
        const start=new Date(); start.setDate(1);
    const keys=[], labels=[];
    for(let i=0;i<12;i++){ const d=new Date(start); d.setMonth(d.getMonth()+i); keys.push(d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0")); labels.push(d.toLocaleString(undefined,{month:"short"})); }
    const count=Object.fromEntries(keys.map(k=>[k,0]));
    norm.filter(r=>r.LeaseEnd).forEach(r=>{ const k=monthKey(r.LeaseEnd); if(k && count[k]!=null) count[k]++; });
    const actual = keys.map(k=>count[k]||0);
    const allowed = keys.map((k,i)=>Math.round((norm.length)*allowedPctByMonth[i%12]));
    overByKey={};
    keys.forEach((k,i)=>{ const over=Math.max(0,(actual[i]||0)-(allowed[i]||0)); if(over>0) overByKey[k]=over; });
    const ctx=$("seasonChart").getContext("2d");
    if(seasonChart) seasonChart.destroy();
    seasonChart = new Chart(ctx,{type:"bar",data:{labels, datasets:[{label:"Actual expirations",data:actual},{label:"Max allowed",type:"line",data:allowed}]},options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{position:"bottom"}},scales:{x:{grid:{display:false}},y:{beginAtZero:true}}}});
    if (rowsTarget && Array.isArray(rowsTarget)) { for(let i=0;i<keys.length;i++){ rowsTarget.push([labels[i], actual[i]||0, allowed[i]||0]); } }
    const overMonths = keys.map((k,i)=> actual[i]>allowed[i]? labels[i]:null).filter(Boolean);
    if(overMonths.length){ flag(`🚩 Over max allowed expirations in: ${overMonths.join(", ")}`); }
  }
  const seasonalityMultiplier=(curve,endKey)=>{
    const curveAlpha = {minimal:0.01, normal:0.02, aggressive:0.03}[curve]||0.02;
    const over = overByKey[endKey]||0;
    return 1 + curveAlpha * over;
  };

  function flag(msg){ const li=document.createElement("li"); li.textContent=msg; $("flagList").appendChild(li); }
  function groupBy(arr,fn){ const m=new Map(); for(const x of arr){ const k=fn(x); m.set(k,(m.get(k)||[]).concat([x])); } return m; }

  // Pricing pieces
  function readCfg(){
    return {
      comfortTarget: num($("comfortTarget").value,95)/100,
      bandLow: Math.max(0.80, Math.min(1.00, (num($("comfortTarget").value,95)-2)/100)),
      bandHigh: Math.max(0.80, Math.min(1.00, (num($("comfortTarget").value,95)+1)/100)),
      convSensitivity: $("convSensitivity").value,
      priceResponse: $("priceResponse").value,
      fpSensitivity: 'medium',
      seasonalityCurve: $("seasonalityCurve").value,
      agedVacantPolicy: $("agedVacantPolicy").value,
      showDiscount: $("showDiscount").checked,
      floorBadge: $("floorBadge").checked,
      // renewals
      allowDecAbove: $("allowDecAbove").checked,
      capAllTerms: $("capAllTerms").checked,
      strengthToMarket: $("strengthToMarket").value,
      pctToNew: num($("pctToNew").value,50)/100,
      renMin: num($("renMin").value,0)/100,
      renMax: num($("renMax").value,10)/100,
      renAboveMin: num($("renAboveMin").value,0)/100,
      renAboveMax: num($("renAboveMax").value,0)/100,
      renewalAwareness: $("renewalAwareness").value,
      renTerms: (window.readRenTermsCompact ? window.readRenTermsCompact() : readRenTerms()),
      nlTerms: (window.readNLTerms ? window.readNLTerms() : [2,3,4,5,6,7,8,9,10,11,12,13,14]),
      maxWeeklyDec: num($("maxWeeklyDec").value,2)/100,
      // safety
      changeCadence: $("changeCadence").value,
      reviewLarge: $("reviewLarge").checked,
      fs_windowDays: num(document.getElementById('fs_windowDays')?.value, 28),
      fs_minLeads: num(document.getElementById('fs_minLeads')?.value, 50),
      fs_thrWeak: num(document.getElementById('fs_thrWeak')?.value, 20),
      fs_thrCautious: num(document.getElementById('fs_thrCautious')?.value, 30)
    };
  }

  function writeCfg(c){
    // Update only our new display settings inputs if present
    try{
      if (document.getElementById('fs_windowDays')) document.getElementById('fs_windowDays').value = String(c.fs_windowDays ?? 28);
      if (document.getElementById('fs_minLeads')) document.getElementById('fs_minLeads').value = String(c.fs_minLeads ?? 50);
      if (document.getElementById('fs_thrWeak')) document.getElementById('fs_thrWeak').value = String(c.fs_thrWeak ?? 20);
      if (document.getElementById('fs_thrCautious')) document.getElementById('fs_thrCautious').value = String(c.fs_thrCautious ?? 30);
    }catch(e){}
    return c;
  }

  // Conversion map
  const CONV = { low:{target:0.20,tol:0.03,step:0.005}, medium:{target:0.25,tol:0.02,step:0.010}, high:{target:0.30,tol:0.015,step:0.015} };
  const PRICE_STEP = {gentle:0.0075, standard:0.015, fast:0.025};


  function computeMoveSingleThreshold(cfg, fpTrend, commTrend, nFp){
    return 0;
  }

  function computeDirSmooth(code, fpLabel, cfg, tState, setupByCode){
    try{
      const row = (setupByCode && setupByCode[code]) || {};
      const low = Number(row.band_low_pct||0) || Math.round((cfg.bandLow||0.93)*100);
      const high= Number(row.band_high_pct||0) || Math.round((cfg.bandHigh||0.96)*100);
      const mid = (low + high) / 2;
      const occ_fp = Number(tState && (tState.tFP[code] ?? tState.tFP[fpLabel])) || 0; // 0..1
      const occ_site = Number(tState && tState.tComm) || 0; // 0..1
      const target_site = Number(cfg && cfg.comfortTarget) || 0.95;

      const dev_pp = (occ_fp*100) - mid; // percent-points
      const sign = dev_pp < 0 ? -1 : (dev_pp > 0 ? +1 : 0);

      const S = { maxMove: 0.05, k: 1.4 }; // Balanced
      const pr = String(cfg && cfg.priceResponse || 'standard').toLowerCase();
      if (pr === 'fast') S.maxMove = 0.08;       // Aggressive: ±8%
      else if (pr === 'gentle') S.maxMove = 0.03; // Conservative: ±3%
      else S.maxMove = 0.05;                     // Standard/Balanced: ±5%

      // Normalize distance: 5pp => x=1
      const x = Math.abs(dev_pp) / 5;
      let mag = S.maxMove * Math.tanh(S.k * x); // 0..maxMove

      // Community bias
      const deltaSitePP = ((occ_site - target_site) * 100);
      let biasMult = 1.0;
      if (deltaSitePP > 1 && sign > 0){
        biasMult = 1 + Math.min(0.15 * deltaSitePP, 0.30);
      } else if (deltaSitePP < -1 && sign < 0){
        biasMult = 1 + Math.min(0.15 * Math.abs(deltaSitePP), 0.30);
      }
      mag *= biasMult;

      if (sign < 0){
        const minDrop   = Number(cfg && cfg.commMinDropWhenAtOrBelowTargetPct) || 0.004; // 0.4%
        const dampStart = Number(cfg && cfg.commDampenStartAboveTargetPP)   || 1.0;      // +1 pp
        const blockAt   = Number(cfg && cfg.commBlockAboveTargetPP)         || 4.0;      // +4 pp
        const slopePP   = Number(cfg && cfg.commDampenSlopePerPP)           || 0.15;     // per-pp
        const dampFloor = Number(cfg && cfg.commDampenFloor)                || 0.25;     // ≥25%

        if (occ_site <= target_site){
          // Enforce minimum negative move when at/below target
          mag = Math.max(mag, minDrop);
        } else {
          // Site above target: dampen or block decreases progressively
          if (deltaSitePP >= blockAt){
            mag = 0;
          } else if (deltaSitePP >= dampStart){
            let factor = 1 - slopePP * (deltaSitePP - dampStart);
            // Clamp factor between dampFloor..1
            factor = Math.max(dampFloor, Math.min(1, factor));
            mag *= factor;
          }
        }
      }

      // Cap to sensitivity max and restore sign
      mag = Math.min(mag, S.maxMove);
      let dir = sign * mag;

      // Center deadband with tiny assist if bias applies
      const CENTER_DEADBAND_PP = 0.3;
      if (Math.abs(dev_pp) < CENTER_DEADBAND_PP){
        if (biasMult > 1.0){
          const tiny = Math.min(0.0025 * (S.maxMove/0.05), 0.005);
          const nudgeSign = sign || (deltaSitePP>0? +1 : -1);
          dir = nudgeSign * tiny;
        } else {
          dir = 0;
        }
      }

      const biasPct = Math.max(0, (biasMult - 1) * 100);
      return { dir: Number.isFinite(dir)? dir: 0, mid, dev_pp, biasPct };
    }catch(e){ return { dir:0, mid:NaN, dev_pp:NaN, biasPct:0 }; }
  }
function computeTrending(norm){
  // Box Score-equivalent helpers
  const status = (s)=> String(s||'').toLowerCase();
  const isVac = (s)=> status(s).includes('vacant');
  const isNotice = (s)=> status(s).includes('notice');
  const isOccLike = (s)=> status(s).startsWith('occupied') || status(s).includes('notice');

  // Community counts
  const N = norm.length;
  let vac = 0, notices = 0, preRaw = 0, occ = 0;
  for(const r of norm){
    const s = status(r.Status);
    if (isVac(s)) vac++;
    if (isNotice(s)) notices++;
    if (isOccLike(s)) occ++;
    if (r.PreleaseStart) preRaw++;
  }
  const pre = Math.min(preRaw, vac + notices); // cannot replace more than pending move-outs
  const occPct = N ? (occ / N) : 0;
  const projected = N ? (1 - ((vac + notices - pre) / N)) : 0;
  const tComm = Math.max(0, Math.min(1, projected));

  // Floorplan-level projected (same rules)
  const byFP = (function groupBy(arr,fn){ const m=new Map(); for(const x of arr){ const k=fn(x); m.set(k,(m.get(k)||[]).concat([x])); } return m; })(norm, r => r.Floorplan || "(unknown)");
  const tFP = {};
  for (const [fp, list] of byFP.entries()){
    const n = list.length;
    let v = 0, no = 0, pr = 0, oc = 0;
    for(const r of list){
      const s = status(r.Status);
      if (isVac(s)) v++;
      if (isNotice(s)) no++;
      if (isOccLike(s)) oc++;
      if (r.PreleaseStart) pr++;
    }
    const pre2 = Math.min(pr, v + no);
    const proj2 = n ? (1 - ((v + no - pre2) / n)) : 0;
    tFP[fp] = Math.max(0, Math.min(1, proj2));
  }

  return { tComm, tFP, occPct }; // occPct included for possible UI chips
}


  function applyIFTHEN(cfg, tFP, tComm, fp){
    const f=tFP[fp]; const c=tComm;
    const low=cfg.bandLow, high=cfg.bandHigh;
    const outsideStep = PRICE_STEP[cfg.priceResponse];
    if (f>high && c<low) return 0;
    if (f>high && c>=low && c<=high) return +outsideStep;
    if (f>high && c>high) return -outsideStep;
    if (f>=low && f<=high && c>high) return 0;
    if (f>=low && f<=high && c>=low && c<=high) return 0;
    if (f>=low && f<=high && c<low) return 0;
    if (f<low && c<low) return -outsideStep;
    if (f<low && c>=low && c<=high) return -outsideStep;
    if (f<low && c>high) return 0;
    return 0;
  }

  function vacancySpecialPct(v){
    if (v>=90) return 0.15;
    if (v>=60) return 0.10;
    if (v>=30) return 0.05;
    return 0;
  }

  function shortTermAdj(base, term){
    if (term>=10) return base;
    const start = 0.08, taper = 0.01;
    const extra = Math.max(0, start - (term-2)*taper);
    return base*(1+extra);
  }

  function renewalBase(current,newLease,cfg,isAbove){
    // Helper: order-aware clamp
    const ordClamp = (x, a, b) => {
      const lo = Math.min(a, b);
      const hi = Math.max(a, b);
      return Math.min(Math.max(x, lo), hi);
    };

    if(!isAbove){
      // BELOW NEW: move toward new by pctToNew, then clamp by [renMin, renMax] (order-aware)
      const target = current + (newLease - current) * (cfg.pctToNew || 0);
      let d = (target / Math.max(1, current)) - 1; // expected >= 0
      const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
      const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
      d = ordClamp(d, lo, hi);
      return current * (1 + d);
    } else {
      // ABOVE NEW: move toward new by pctToNew (typically negative), respect allowDecAbove,
      // then clamp by [renAboveMin, renAboveMax] (order-aware; values may be negative)
      const toward = current - (current - newLease) * (cfg.pctToNew || 0);
      let d = (toward / Math.max(1, current)) - 1; // typically < 0
      if (!cfg.allowDecAbove) d = Math.max(0, d); // disallow decreases if configured

      const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
      const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0; // negative max => allow decreases
      d = ordClamp(d, loRaw, hiRaw);

      return current * (1 + d);
    }
  }

  function applyRenewalGuardrailMax(cfg, pctChange, isAbove, allowDecAbove){
    // pctChange is (finalPrice/current) - 1 AFTER premiums
    if (!isAbove){
      // BELOW new lease path: cap upward % by renMax; do NOT enforce a min.
      const cappedUp = Math.min(pctChange, cfg.renMax||0);
      return cappedUp;
    } else {
      // ABOVE new lease path:
      // - If decreases are not allowed, clamp negatives to 0 first.
      let p = allowDecAbove ? pctChange : Math.max(0, pctChange);
      // Apply above-new "max %" as an absolute magnitude cap (symmetric)
      const limit = Math.abs(cfg.renAboveMax||0);
      if (p > 0) p = Math.min(p, limit);
      if (p < 0) p = Math.max(p, -limit);
      return p;
    }
  }

  function explain(chips){
    const cap=chips.slice(0,3);
    return `<div>${cap.map(c=>`<span class="badge">${c}</span>`).join(" ")}</div>`;
  }

  // Debug helpers for base formula (added for Renewals debug)
  if (typeof _fmtPct !== 'function'){
    function _fmtPct(p){ return ((p*100).toFixed(1) + '%'); }
  }
  if (typeof _clampOrdered !== 'function'){
    function _clampOrdered(x, a, b){ const lo = Math.min(a, b), hi = Math.max(a, b); return Math.min(Math.max(x, lo), hi); }
  }
  if (typeof buildRenewalBaseFormulaDebug !== 'function'){
    function buildRenewalBaseFormulaDebug(current, newLease, cfg){
      const isAbove = current > newLease;
      const pctToNew = cfg.pctToNew || 0;
      if (!isAbove){
        const target = current + (newLease - current) * pctToNew;
        const rawPct = (target / Math.max(1, current)) - 1;
        const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
        const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
        const basePct = _clampOrdered(rawPct, lo, hi);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (below-new): ',
          `target = ${fmt(target)} = ${fmt(current)} + ${_fmtPct(pctToNew)}×(${fmt(newLease)} − ${fmt(current)})`,
          `; raw ${_fmtPct(rawPct)} → clamp[${_fmtPct(lo)}, ${_fmtPct(hi)}] = ${_fmtPct(basePct)}`,
          ` → base ${fmt(base)}`
        ].join('');
      } else {
        const toward = current - (current - newLease) * pctToNew;
        let rawPct = (toward / Math.max(1, current)) - 1; // typically negative
        const allowDec = !!cfg.allowDecAbove;
        const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
        const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0;
        const afterAllow = allowDec ? rawPct : Math.max(0, rawPct);
        const basePct = _clampOrdered(afterAllow, loRaw, hiRaw);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (above-new): ',
          `toward = ${fmt(toward)} = ${fmt(current)} − ${_fmtPct(pctToNew)}×(${fmt(current)} − ${fmt(newLease)})`,
          `; raw ${_fmtPct(rawPct)}`,
          allowDec ? '' : ' → no-decrease max(0, raw)',
          ` → clamp[${_fmtPct(loRaw)}, ${_fmtPct(hiRaw)}] = ${_fmtPct(basePct)}`,
          ` → base ${fmt(base)}`
        ].join('');
      }
    }
  }

  // Debug helpers for base formula (safe additions)
  if (typeof _fmtPct !== 'function'){
    function _fmtPct(p){ return ((p*100).toFixed(1) + '%'); }
  }
  if (typeof _clampOrdered !== 'function'){
    function _clampOrdered(x, a, b){ const lo = Math.min(a, b), hi = Math.max(a, b); return Math.min(Math.max(x, lo), hi); }
  }
  if (typeof buildRenewalBaseFormulaDebug !== 'function'){
    function buildRenewalBaseFormulaDebug(current, newLease, cfg){
      const isAbove = current > newLease;
      const pctToNew = cfg.pctToNew || 0;
      if (!isAbove){
        const target = current + (newLease - current) * pctToNew;
        const rawPct = (target / Math.max(1, current)) - 1;
        const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
        const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
        const basePct = _clampOrdered(rawPct, lo, hi);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (below-new): ',
          `target = ${fmt(target)} = ${fmt(current)} + ${_fmtPct(pctToNew)}×(${fmt(newLease)} − ${fmt(current)})`,
          `; raw ${_fmtPct(rawPct)} → clamp[${_fmtPct(lo)}, ${_fmtPct(hi)}] = ${_fmtPct(basePct)}`,
          ` → base ${fmt(base)}`
        ].join('');
      } else {
        const toward = current - (current - newLease) * pctToNew;
        let rawPct = (toward / Math.max(1, current)) - 1; // typically negative
        const allowDec = !!cfg.allowDecAbove;
        const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
        const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0;
        const afterAllow = allowDec ? rawPct : Math.max(0, rawPct);
        const basePct = _clampOrdered(afterAllow, loRaw, hiRaw);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (above-new): ',
          `toward = ${fmt(toward)} = ${fmt(current)} − ${_fmtPct(pctToNew)}×(${fmt(current)} − ${fmt(newLease)})`,
          `; raw ${_fmtPct(rawPct)}`,
          allowDec ? '' : ' → no-decrease max(0, raw)',
          ` → clamp[${_fmtPct(loRaw)}, ${_fmtPct(hiRaw)}] = ${_fmtPct(basePct)}`,
          ` → base ${fmt(base)}`
        ].join('');
      }
    }
  }

  
function collectNewFloorplanPoints(cfg, norm, tState){
  // returns summary points per floorplan (do not bake aged-vacancy into adjusted)
  const byFP = groupBy(norm, r => r.Floorplan || "(unknown)");
  const setupByCode = (typeof buildSetupByCode === 'function') ? buildSetupByCode() : {};
  const out = [];
  for(const [fp, list] of byFP.entries()){
    const avgCurr = list.reduce((s,r)=>s+(r.CurrentRent||0),0)/Math.max(1,list.length);
    const code = String((list[0] && (list[0].FP_CODE || list[0].Floorplan)) || fp);
    const srVal = startingRentForCode(code);
    const sr = Number(srVal||0);
    const base = (sr && sr > 0) ? sr : avgCurr; // Starting Rent anchor by code; fallback to current avg
    const fpN = list.length;
    const fpTrend = tState.tFP[code] ?? tState.tFP[fp];
    const commTrend = tState.tComm;
    const smTop = computeDirSmooth(code, fp, cfg, tState, setupByCode);
    const dir = smTop.dir;
    let adjusted = base*(1+dir);
    if (dir<0) adjusted = Math.max(adjusted, base*(1-cfg.maxWeeklyDec));
    const vacs = list.filter(r=>r.Status==="vacant").map(r=> (r.VacantDays||0));
    let avgVacPct = 0;
    if(vacs.length){
      const vacPct = vacs.map(v => (v>=90?0.15:(v>=60?0.10:(v>=30?0.05:0))));
      avgVacPct = vacPct.reduce((a,b)=>a+b,0)/vacs.length;
    }
    out.push({
      fp: fp,
      code: code,
      base: base,
      dir: dir,
      adjusted: Math.round(adjusted),
      avgVacPct: avgVacPct,
      startingRent: (sr && sr>0) ? sr : null,
      price: Math.round(adjusted),
      baselineSource: (sr && sr>0) ? 'starting' : 'current'
    });
  }
  // stable sort by name for consistency
  out.sort((a,b)=> a.fp.localeCompare(b.fp));
  return out;
}

  function buildSetupByCode(){
    const out = Object.create(null);
    try{
      const fps = (window.propertySetup && Array.isArray(window.propertySetup.floorplans)) ? window.propertySetup.floorplans : [];
      for(const fp of fps){ if (fp && fp.code){ out[String(fp.code)] = fp; } }
    }catch(e){}
    return out;
  }
  // Helper: prefer starting_rent over reference_ask
  function startingRentForCode(code){
    try{
      const fps = (window.propertySetup && window.propertySetup.floorplans) || [];
      const fp = fps.find(x => String(x.code||'') === String(code||''));
      const v = fp && Number((fp.starting_rent ?? fp.reference_ask));
      return (Number.isFinite(v) && v > 0) ? v : null;
    }catch(e){ return null; }
  }
  function buildLowerTierMap(fps){
    function srOf(x){ return Number((x&&x.starting_rent)!=null ? x.starting_rent : x&&x.reference_ask || 0) || 0; }
    const byAsk = (fps||[]).filter(fp => srOf(fp) > 0)
                  .slice().sort((a,b)=> srOf(a)-srOf(b));
    const map = new Map();
    for (let i=0;i<byAsk.length;i++){
      const fp = byAsk[i];
      const lower = i>0 ? byAsk[i-1] : null;
      map.set(fp.code, lower);
    }
    return map;
  }

  function renderNewLease(cfg,norm,tState){
    const wrap=$("nlTables"); wrap.innerHTML="";
    // Footnote about guardrail
    wrap.insertAdjacentHTML('beforeend', '<div class="note">Buffer guardrail blocks decreases that would cross a floorplan\'s buffer vs the next lower tier.</div>');

    // Build floorplan setup maps once per run
    const setupRows = (window.propertySetup && Array.isArray(window.propertySetup.floorplans)) ? window.propertySetup.floorplans : [];
    const setupByCode = buildSetupByCode();
    const lowerMap = buildLowerTierMap(setupRows);
    const byFP=groupBy(norm,r=>r.Floorplan||"(unknown)");
    // local helper to safely read saved FP map
    function _safeLoadFPMap(){ try{ const ps=window.propertySetup||{}; const pid=ps.property_id||ps.property_name||'default'; return JSON.parse(localStorage.getItem(`rm:fpmap:${pid}`))||{}; }catch(e){ return {}; } }
    // Helper: derive bedroom from code/name
    function _bed(code){
      const row = setupByCode[code]||{}; const name=String(row.name||''); const c=String(code||''); const s=(c+' '+name).toLowerCase();
      if (/\b(s0|studio|0x1)\b/i.test(c) || /\b(studio|0x1)\b/.test(name.toLowerCase())) return 0;
      if (/\b1x1\b/i.test(s) || /\b1\s*br\b/i.test(s)) return 1;
      if (/\b2x2\b/i.test(s) || /\b2\s*br\b/i.test(s)) return 2;
      if (/\b3x\d\b/i.test(s) || /\b3\s*br\b/i.test(s)) return 3;
      if (/\b4x\d\b/i.test(s) || /\b4\s*br\b/i.test(s)) return 4;
      if (/^a/i.test(c)) return 1; if (/^b/i.test(c)) return 2; if (/^c/i.test(c)) return 3;
      const m1=s.match(/(\d)\s*br/); if(m1) return parseInt(m1[1]); const m2=s.match(/(\d)\s*x\s*(\d)/); if(m2) return parseInt(m2[1]);
      return 1;
    }
    // Build current baselines and tier anchors by bedroom
    const baselineCurrentByCode=new Map(); const bedByCode=new Map(); const tierMaxCurrent=new Map();
    // Precompute gap-to-next per lower tier (max across floorplans in that tier)
    const gapToNextByBed = new Map();
    for(const [fp0,list0] of byFP.entries()){
      const lbl0 = String(list0[0]?.Floorplan || fp0 || '').trim();
      const mapped0 = _safeLoadFPMap()[lbl0];
      const code0 = String(list0[0]?.FP_CODE || mapped0 || firstToken(lbl0) || lbl0).trim();
      const s0 = setupByCode[code0];
      const bed0 = (function(){ const row=s0||{}; const name=String(row.name||''); const c=String(code0||''); const s=(c+' '+name).toLowerCase(); if(/\b(s0|studio|0x1)\b/i.test(c)||/\b(studio|0x1)\b/.test(name.toLowerCase()))return 0; if(/\b1x1\b/i.test(s)||/\b1\s*br\b/i.test(s))return 1; if(/\b2x2\b/i.test(s)||/\b2\s*br\b/i.test(s))return 2; if(/\b3x\d\b/i.test(s)||/\b3\s*br\b/i.test(s))return 3; if(/\b4x\d\b/i.test(s)||/\b4\s*br\b/i.test(s))return 4; if(/^a/i.test(c))return 1; if(/^b/i.test(c))return 2; if(/^c/i.test(c))return 3; const m1=s.match(/(\d)\s*br/); if(m1)return parseInt(m1[1]); const m2=s.match(/(\d)\s*x\s*(\d)/); if(m2)return parseInt(m2[1]); return 1; })();
      const g = Number((s0 && s0.gap_to_next_tier_dollars) || 0) || 0;
      if (g>0){ gapToNextByBed.set(bed0, Math.max(gapToNextByBed.get(bed0)||0, g)); }
    }

    for(const [fp,list] of byFP.entries()){
      const lbl=String(list[0]?.Floorplan||fp||'').trim(); const mapped=_safeLoadFPMap()[lbl]; const code=String(list[0]?.FP_CODE||mapped||firstToken(lbl)||lbl).trim();
      const avgCurr = list.reduce((s,r)=>s+(r.CurrentRent||0),0)/Math.max(1,list.length);
      const sRow = setupByCode[code]; const sr = Number((sRow?.starting_rent ?? sRow?.reference_ask) || 0);
      const baseCurr = (avgCurr && avgCurr>0) ? avgCurr : (sr>0?sr:0);
      baselineCurrentByCode.set(code, baseCurr);
      const bed=_bed(code); bedByCode.set(code, bed);
      const prev=tierMaxCurrent.get(bed)||0; if (baseCurr>prev) tierMaxCurrent.set(bed, baseCurr);
    }
    const minTier = tierMaxCurrent.size? Math.min(...Array.from(tierMaxCurrent.keys())) : 0;
    // Helper: seasonality multiplier from UI array (clamped)
    function getSeasonalityMultiplier(monthIndex){
      const a = (window.__seasonalityArray__ || []);
      const v = Number(a[monthIndex]);
      const m = Number.isFinite(v) ? v : 1;
      return Math.min(1.20, Math.max(0.80, m));
    }
    let spacingClampCountBase = 0;
    for(const [fp,list] of byFP.entries()){
      const lbl = String(list[0]?.Floorplan || fp || '').trim();
      const mapped = _safeLoadFPMap()[lbl];
      const code = String(list[0]?.FP_CODE || mapped || firstToken(lbl) || lbl).trim();
      const avgCurr = list.reduce((s,r)=>s+(r.CurrentRent||0),0)/Math.max(1,list.length);
      const s = setupByCode[code];
      const sr = Number((s?.starting_rent ?? s?.reference_ask) || 0);
      const base = (sr > 0) ? sr : avgCurr; // Starting Rent anchor by code
      const baselineSource = (sr > 0) ? 'starting' : 'current';
      const fpN = list.length;
      const fpTrend = (tState.tFP[code] ?? tState.tFP[fp]);
      const commTrend = tState.tComm;
      const smTop2 = computeDirSmooth(code, fp, cfg, tState, setupByCode);
      const dir = smTop2.dir;
      const T = (typeof cfg?.comfortTarget === 'number') ? cfg.comfortTarget : 0.95;
      const DB = 0.005;
      // decide reference term = longest selected new-lease term
      const terms = (cfg && Array.isArray(cfg.nlTerms) && cfg.nlTerms.length)
        ? cfg.nlTerms
        : [2,3,4,5,6,7,8,9,10,11,12,13,14];
      const refTerm = Math.max.apply(null, terms);
      var _refPrice = null; // will capture later
      var _refBasePrePremium = null; // capture base (pre-premiums) for reference term

      let adjusted = base*(1+dir);
      if (dir<0) adjusted = Math.max(adjusted, base*(1-cfg.maxWeeklyDec));
      const vacs = list.filter(r=>r.Status==="vacant").map(r=>vacancySpecialPct(r.VacantDays||0));
      const avgVac = vacs.length? (vacs.reduce((a,b)=>a+b,0)/vacs.length) : 0; // apply only to short terms below

      let guardrailChip = '';
      try{
        const s = setupByCode[code];
        const lower = lowerMap.get(code);
        const B = Number(s && s.stop_down_buffer_dollars || 0);
        const fpRef = Number((s&&s.starting_rent)!=null ? s.starting_rent : (s&&s.reference_ask)||0);
        const L = Number((lower&&lower.starting_rent)!=null ? lower.starting_rent : (lower&&lower.reference_ask)||0);
        const hasLower = !!lower;
        const isDecrease = adjusted < base; // stop-decrease only
        if (hasLower && B>0 && L>0 && fpRef>0 && isDecrease){
          const minAllowed = L + B;
          if (adjusted < minAllowed){
            adjusted = minAllowed;
            const minInt = Math.round(minAllowed);
            const bInt = Math.round(B);
            guardrailChip = `<span class=\"badge\">🧱 Buffer guardrail: kept ≥ ${minInt} vs ${lower.code} + ${bInt}</span>`;
          }
        }
      }catch(e){}
      adjusted = (typeof clampBaseToFPCaps === 'function') ? clampBaseToFPCaps(adjusted, code) : adjusted;

      let trs="";
      // Process ascending by bedroom
      const codesByBed = Array.from(byFP.entries()).map(([fpL, listL])=>{
        const lbl = String(listL[0]?.Floorplan || fpL || '').trim();
        const mapped = _safeLoadFPMap()[lbl];
        const code = String(listL[0]?.FP_CODE || mapped || firstToken(lbl) || lbl).trim();
        return { code, bed: (bedByCode.get(code) ?? 1), list: listL };
      }).sort((a,b)=> a.bed - b.bed);
      // Precompute sr, base, dir
      const srByCode = new Map(); const dirByCode = new Map();
      for(const {code, list: listL} of codesByBed){
        const sRow = setupByCode[code];
        const avgCurr = listL.reduce((s,r)=>s+(r.CurrentRent||0),0)/Math.max(1,listL.length);
        const sr = Number((sRow?.starting_rent ?? sRow?.reference_ask) || 0);
        const base = (sr > 0) ? sr : avgCurr;
        srByCode.set(code, sr);
        const fpN = listL.length;
        const fpTrend = (tState.tFP[code] ?? tState.tFP[String(listL[0]?.Floorplan||'')]);
        const commTrend = tState.tComm;
        const sm2 = computeDirSmooth(code, String(listL[0]?.Floorplan||''), cfg, tState, setupByCode);
        dirByCode.set(code, sm2.dir);
      }
      // Helper: build baseFinal per code for a given term (seasonality-aware) and apply gap stopper
      function __buildBaseFinalByCodeForTerm(term){
        const map = new Map();
        // Seasonality is not applied in Base; compute once without seas
        const seas = 1;
        for(const {code, bed} of codesByBed){
          const srVal = Number(srByCode.get(code)||0);
          const baseVal = (srVal>0? srVal : Number(baselineCurrentByCode.get(code)||0));
          const dirVal = Number(dirByCode.get(code)||0);
          let baseCand = baseVal * (1 + dirVal) * seas;
          if (dirVal<0) baseCand = Math.max(baseCand, baseVal*(1 - cfg.maxWeeklyDec));
          if (bed > minTier){
            const lowerBed = bed - 1;
            const lowerCodes = codesByBed.filter(x=>x.bed===lowerBed).map(x=>x.code);
            const lowerBases = lowerCodes.map(c=> map.get(c)).filter(v=>Number.isFinite(v));
            if (lowerBases.length){
              const lowerMaxBase = Math.max.apply(null, lowerBases);
              const minGap = Math.max(Number(gapToNextByBed.get(lowerBed)||0)||0, 0);
              const stopper = lowerMaxBase + minGap;
              if (baseCand < stopper){ baseCand = stopper; spacingClampCountBase++; }
            }
          }
          baseCand = (typeof clampBaseToFPCaps === 'function') ? clampBaseToFPCaps(baseCand, code) : baseCand;
          map.set(code, baseCand);
        }
        return map;
      }

      // kept as no‑op – legacy reference (remove in a later refactor)
      // Build base map WITHOUT tier-gap stopper (still respecting weekly dec cap and FP caps)
      function __buildBaseNoGapByCodeForTerm(term){
        const map = new Map();
        const seas = 1;
        for(const {code} of codesByBed){
          const srVal = Number(srByCode.get(code)||0);
          const baseVal = (srVal>0? srVal : Number(baselineCurrentByCode.get(code)||0));
          const dirVal = Number(dirByCode.get(code)||0);
          let baseCand = baseVal * (1 + dirVal) * seas;
          if (dirVal<0) baseCand = Math.max(baseCand, baseVal*(1 - cfg.maxWeeklyDec));
          baseCand = (typeof clampBaseToFPCaps === 'function') ? clampBaseToFPCaps(baseCand, code) : baseCand;
          map.set(code, baseCand);
        }
        return map;
      }

      // Compute tier-gap uplift info on the reference term only (for explainability)
      const __refBaseNoGap = __buildBaseNoGapByCodeForTerm(refTerm);
      const __refBaseWithGap = __buildBaseFinalByCodeForTerm(refTerm);
      const tierGapDeltaByCode = new Map();
      const tierGapMetaByCode = new Map(); // {lowerCode, lowerRef, gap, requiredMin}
      // Precompute lower-tier anchors (which lower code sets the requirement)
      const byBedCodes = new Map();
      codesByBed.forEach(x=>{ const a=byBedCodes.get(x.bed)||[]; a.push(x.code); byBedCodes.set(x.bed,a); });
      for (const {code, bed} of codesByBed){
        const baseNoGap = Number(__refBaseNoGap.get(code)||0);
        const baseWithGap = Number(__refBaseWithGap.get(code)||0);
        const delta = Math.max(0, Math.round(baseWithGap - baseNoGap));
        if (bed > minTier && delta > 0){
          const lowerBed = bed - 1;
          const lowerCodes = byBedCodes.get(lowerBed)||[];
          let bestLower = null, bestVal = -Infinity;
          lowerCodes.forEach(c=>{ const v = Number(__refBaseWithGap.get(c)||0); if (Number.isFinite(v) && v>bestVal){ bestVal=v; bestLower=c; } });
          const gap = Math.max(Number(gapToNextByBed.get(lowerBed)||0)||0, 0);
          const requiredMin = Math.round(bestVal + gap);
          tierGapDeltaByCode.set(code, delta);
          tierGapMetaByCode.set(code, { lowerCode: bestLower||'', lowerRef: Math.round(bestVal), gap: Math.round(gap), requiredMin });
        }
      }

      for(const term of terms){
        // Base-first: long terms (>=10) anchor to moved base; short terms apply short-term premium
        const longTerm = term >= 10;
        const baseFinalByCode = __buildBaseFinalByCodeForTerm(term);
        const p0 = baseFinalByCode.get(code) ?? adjusted; // apply base stopper before per-term math

        const end = new Date(); end.setMonth(end.getMonth()+term);
        const key = end.getFullYear()+"-"+String(end.getMonth()+1).padStart(2,"0");
        const overCapCount = (typeof overByKey === 'object' && overByKey) ? (overByKey[key] || 0) : 0;
        const overCapPct = (function(){
          const el = $('seasonalityCurve');
          const mm = (typeof seasonalityMultiplier === 'function' && el) ? seasonalityMultiplier(el.value, key) : 1;
          return (mm - 1);
        })();

        // Term adjustments combined on base: short + overCap (no aged vacancy in New Pricing)
        const shortPct = longTerm ? 0 : (shortTermAdj(100, term)/100 - 1);
        // Seasonality uplift only on over-cap terms and only if positive
        const seasArr = (window.__seasonalityArray__ || []);
        const monthIdx = end.getMonth();
        const m = Number(seasArr[monthIdx]);
        const seasonalityPct = (Number.isFinite(m) ? (m - 1) : 0);
        const seasonalUplift = (seasonalityPct>0 && (overCapCount>0)) ? seasonalityPct : 0;
        let p = p0 * (1 + (shortPct||0) + (overCapPct||0) + (seasonalUplift||0));

        // Gap stopper already applied at base stage — do not clamp per term

        // capture reference term display price and base (pre-premiums)
        if (term === refTerm) { _refPrice = Math.round(p); _refBasePrePremium = Math.round(p0); }

        // format compact math: X% & over cap (N) Y% = Z%
        const x = (shortPct * 100);
        const y = ((overCapPct||0) * 100);
        const seasPctOut = ((seasonalUplift||0) * 100);
        // Net vs BaseFinal after term adjustments
        const totalPct = ((p / Math.max(1, p0)) - 1) * 100;
        const signFmt = (v)=> (v>=0? '+' : '−') + Math.abs(v).toFixed(1) + '%';
        const notes = `Term premium ${signFmt(x)} & over cap (${overCapCount}) ${signFmt(y)} +seasonal ${signFmt(seasPctOut)} = ${signFmt(totalPct)}`;

        // single row: term | price | notes (right-aligned)
        trs += `<tr>
                  <td>${term} mo</td>
                  <td>${fmt(p)}</td>
                  <td style="text-align:right; opacity:.9"><small>${notes}</small></td>
                </tr>`;

        // export includes Starting Rent anchor (only SR value in column 2)
        __newPricingRows.push([code || fp, Math.round(sr>0?sr:0), term, Math.round(p)]);
      }

      const arrow = (dir > 0.0001) ? "↑" : (dir < -0.0001) ? "↓" : "→";
      const smDbg = computeDirSmooth(code, fp, cfg, tState, setupByCode);
      const baseCandDbg = (sr>0?sr:base) * (1+dir);
      let _capTxt = '';
      try{
        const cl = (typeof clampBaseToFPCaps === 'function') ? clampBaseToFPCaps(baseCandDbg, code) : baseCandDbg;
        if (cl > baseCandDbg) _capTxt = ' • cap:floor';
        else if (cl < baseCandDbg) _capTxt = ' • cap:ceiling';
      }catch(e){}
      const dbgLine = `
        <div class="note" style="margin-top:6px;opacity:.9">
          Debug — ${arrow} reference: ${refTerm} mo @ ${fmt(_refPrice)}
          • Starting Rent ${fmt(sr>0?sr:avgCurr)}
          • baseline = ${baselineSource}
          • move=${(dir*100).toFixed(2)}%
          • mid=${Number(smDbg.mid).toFixed(1)}% • dev=${(Number(smDbg.dev_pp)>=0?'+':'')+Number(smDbg.dev_pp).toFixed(1)} pp • dir=${(Number(smDbg.dir)*100).toFixed(1)}% • siteBias=${(Number(smDbg.biasPct)||0).toFixed(0)}%
          • dir=${(dir*100).toFixed(2)}% • sr=${Math.round(sr>0?sr:base)} • base=${baseCandDbg.toFixed(1)}${_capTxt}
          • Target ${(T*100).toFixed(1)}%
          • FP ${(fpTrend*100).toFixed(1)}%
          • Comm ${(commTrend*100).toFixed(1)}%
          • n=${fpN}
        </div>`;
      // Simple Target/Gate debug line (no extra helpers)
      const _gateDown = T - 0.02;
      const _gateUp   = T + 0.01;
      const _fpVsT_pp = ((fpTrend - T) * 100);          // percent-points
      const _fpVsT_txt = (Math.abs(_fpVsT_pp) < 0.05)
        ? "FP vs Target: 0.0pp"
        : ("FP vs Target: " + (_fpVsT_pp > 0 ? "+" : "−") + Math.abs(_fpVsT_pp).toFixed(1) + "pp");
      const _gate_txt = (commTrend <= _gateDown)
        ? "Community gate: Blocked"
        : (commTrend >= _gateUp ? "Community gate: Boost" : "Community gate: Neutral");
      const dbgLine2 = `
        <div class="note" style="margin-top:2px;opacity:.85">
          ${_fpVsT_txt} • ${_gate_txt}
        </div>`;

      // Optional tier-gap chip if applied on reference term
      const __tg = tierGapDeltaByCode.get(code)||0;
      const __tgMeta = tierGapMetaByCode.get(code)||null;
      const tierGapChip = (__tg>0 && __tgMeta)
        ? `<span class=\"badge\">tier gap +$${__tg} to maintain $${__tgMeta.gap} vs ${__tgMeta.lowerCode}</span>`
        : '';

      wrap.insertAdjacentHTML("beforeend",`
        <div style="border:1px solid #0b2035;border-radius:10px;padding:10px;margin:8px 0">
          <div style="font-weight:600">${code} ${guardrailChip} ${tierGapChip}</div>
          <table class="basic" style="margin-top:6px">
            <thead><tr><th>Term</th><th>Price</th><th style="text-align:right;">Notes</th></tr></thead>
            <tbody>${trs}</tbody>
            <tfoot id="boxScoreFoot"><tr><td colspan="8" class="note">Totals will appear after you run.</td></tr></tfoot>
          </table>
          ${explain([
            (tState.tFP[code] ?? tState.tFP[fp])>$("comfortHigh").value/100? "Trend above comfort":"Trend below/within comfort",
            "Price response: "+$("priceResponse").value,
            "Seasonality: "+$("seasonalityCurve").value
          ])}
          ${dbgLine}
          ${(__tg>0 && __tgMeta)? `<div class=\"note\" style=\"margin-top:2px;opacity:.85\">• tierGap=+$${__tg} (need ≥ $${__tgMeta.lowerRef} + $${__tgMeta.gap} = $${__tgMeta.requiredMin})</div>` : ''}
        </div>`);
      // Collect reference/base per FP for unit pricing view
      try{
        window.__fpResults = Array.isArray(window.__fpResults)? window.__fpResults: [];
        window.__fpResults.push({ code, name:(s?.name||code), startingRent: sr, referenceBase: Number(_refBasePrePremium||0), referenceTerm: refTerm, price_ceiling_dollars: (s && s.price_ceiling_dollars!=='' && s.price_ceiling_dollars!=null)? Number(s.price_ceiling_dollars) : null });
      }catch(e){}
    }
    // Summary note for spacing clamps
    if (spacingClampCountBase>0){
      wrap.insertAdjacentHTML('beforeend', `<div class="note" style="margin-top:6px">Spacing applied: Some floorplans were raised to maintain the minimum gap vs the lower bedroom tier’s base.</div>`);
    }
    // Render unit section if enabled
    try{ if (typeof window.__renderUnitPricingSection==='function') window.__renderUnitPricingSection(); }catch(e){}
  }


function renderRenewals(cfg,norm,tState){
  const wrap = $("renTables"); 
  wrap.innerHTML = "";

  const byFP = groupBy(norm, r => r.Floorplan || "(unknown)");
  const terms = (cfg && Array.isArray(cfg.renTerms) && cfg.renTerms.length)
    ? cfg.renTerms
    : (window.readRenTermsCompact ? window.readRenTermsCompact() : readRenTerms());
  const refTerm = Math.max.apply(null, terms);

  // occupied units with a lease-end date, oldest first
  const renewals = (norm||[])
    .filter(x => String(x.Status||"").toLowerCase().startsWith("occupied") && x.LeaseEnd)
    .sort((a,b)=> new Date(a.LeaseEnd) - new Date(b.LeaseEnd));

  // If no eligible renewals, show a friendly note instead of a blank panel
  if (!renewals.length){
    wrap.innerHTML = '<div class="note">No renewal candidates found for this dataset.</div>';
    return;
  }

    for (const r of renewals){
    const fp = r.Floorplan || "(unknown)";
    const fpList = byFP.get(fp) || [];
    const fpAvg = fpList.reduce((s,u)=> s + (u.CurrentRent||0), 0) / Math.max(1, fpList.length);
    const fpN = fpList.length;

    // trending + move direction
    const fpTrend   = tState.tFP[fp];
    const commTrend = tState.tComm;
    const smDbgTop = computeDirSmooth(fp, fp, cfg, tState, setupByCode);
    const dir = smDbgTop.dir;

    // === Baseline new anchored to Starting Rent (by code) ===
    const sr = Number((startingRentForCode(fp)) || 0);
    const anchor = (sr && sr > 0) ? sr : fpAvg;
    const baselineNew = anchor * (1 + dir);
    const curr = r.CurrentRent || 0;

    let trs = "";
    let _refRenewPrice = NaN;

    for (const term of terms){
      // Whether current is above today's baseline-new
      const isAboveNew = curr > baselineNew;

// --- RENEWALS: per-term computation (surgical patch) ---
// 1) Build base using existing renewalBase
const basePrice = renewalBase(curr, baselineNew, cfg, isAboveNew);
let basePct = (basePrice / Math.max(1, curr)) - 1;

// 2) Term premiums = short-term (2–9) + seasonality.
const end = new Date(); end.setMonth(end.getMonth() + term);
const key = end.getFullYear() + "-" + String(end.getMonth()+1).padStart(2, "0");

// Start from basePrice to compute the multiplicative term effects just like New
const baseAfterShort = shortTermAdj(basePrice, term); // if term>=10, it's unchanged
const shortTermPctDec = (baseAfterShort / Math.max(1, basePrice)) - 1; // decimal

const monthMult = seasonalityMultiplier(cfg.seasonalityCurve, key) || 1;
const seasonalityPctDec = (monthMult - 1); // decimal
const overCount = (overByKey && overByKey[key]) ? overByKey[key] : 0;

// Apply term effects multiplicatively to basePrice to get the raw term price
const rawTermPrice = baseAfterShort * monthMult;

// 3) Convert to final % vs current and apply guardrails policy
let pctFinal = (rawTermPrice / Math.max(1, curr)) - 1;
if (cfg.capAllTerms === true) {
  // Per-term MAX-only cap after premiums
  pctFinal = applyRenewalGuardrailMax(cfg, pctFinal, isAboveNew, cfg.allowDecAbove);
} else {
  // No per-term cap. If above-new and decreases are not allowed, prevent negative final pct.
  if (isAboveNew && !cfg.allowDecAbove) {
    pctFinal = Math.max(0, pctFinal);
  }
}

// Final offer (rounded)
const offer = Math.round(curr * (1 + pctFinal));

// --- Notes formatting (match New style). When guardrails OFF, omit "max-cap ..." ---
const pctToStr = v => `${(v*100).toFixed(1)}%`;
const parts = [];
parts.push(`term premium ${pctToStr(shortTermPctDec)}`);
if (overCount && seasonalityPctDec !== 0) {
  parts.push(`& over cap (${overCount}) ${pctToStr(Math.max(0, seasonalityPctDec))}`);
} else {
  parts.push(`& seasonality ${pctToStr(seasonalityPctDec)}`);
}
const termSumDec = shortTermPctDec + seasonalityPctDec;
const left = `${parts.join(' ')} = ${pctToStr(termSumDec)}`;
let note = left + ` → applied ${pctToStr(pctFinal)}`;
if (cfg.capAllTerms === true) {
  const maxCap = isAboveNew ? Math.abs(cfg.renAboveMax || 0) : Math.abs(cfg.renMax || 0);
  note = `${left} → max-cap ${pctToStr(maxCap)} → applied ${pctToStr(pctFinal)}`;
}

      trs += `<tr>
                <td>${term} mo</td>
                <td>${fmt(offer)}</td>
                <td style="text-align:right;opacity:.9"><small>${note}</small></td>
              </tr>`;

      // Include Starting Rent and Baseline New in export
      __renewalsRows.push([
        r.UnitID, fp, fmtDate(r.LeaseEnd), term,
        offer, Math.round(curr), Math.round(sr>0?sr:fpAvg), Math.round(baselineNew),
        Math.round((cfg.pctToNew||0)*100)+'%',
        (isAboveNew?cfg.renAboveMin:cfg.renMin), (isAboveNew?cfg.renAboveMax:cfg.renMax)
      ]);
    }

    // Footer debug: Current vs baseline-new, plus knobs and applied on reference term
  const appliedPct = (isFinite(_refRenewPrice) && curr>0) ? ((_refRenewPrice/curr - 1)*100) : NaN;
  const appliedTxt = isFinite(appliedPct) ? ((appliedPct>=0?'+':'−')+Math.abs(appliedPct).toFixed(1)+'%') : '—';
  const pctToNewTxt = Math.round((cfg.pctToNew||0)*100) + '%';
  const maxOnly = Math.max(0, (cfg.renMax||0), (cfg.renAboveMax||0));
  const maxTxt = maxOnly ? (Math.round(maxOnly*1000)/10).toFixed(1)+'%' : '—';
  const baseLine = (typeof buildRenewalBaseFormulaDebug==='function') ? buildRenewalBaseFormulaDebug(curr, baselineNew, cfg) : '';

    const footerDebug = `
      <div class="note" style="margin-top:6px;opacity:.9">
        Debug — Current ${fmt(curr)} • Starting Rent ${fmt(sr>0?sr:fpAvg)} • baseline-new ${fmt(baselineNew)}
        • pct-to-new: ${pctToNewTxt} • max: ${maxTxt} → applied ${appliedTxt}
        <br><span style="opacity:.85">${baseLine}</span>
      </div>`;

    wrap.insertAdjacentHTML("beforeend", `
      <div style="border:1px solid #0b2035;border-radius:10px;padding:10px;margin:8px 0">
        <div style="font-weight:600">Unit ${r.UnitID} — ${fp} — Lease End ${fmtDate(r.LeaseEnd)} — Current ${fmt(curr)}</div>
        <table class="basic" style="margin-top:6px">
          <thead><tr><th>Term</th><th>Offer</th><th style="text-align:right;">Notes</th></tr></thead>
          <tbody>${trs}</tbody>
        </table>
        ${footerDebug}
        ${explain([
          (curr >= baselineNew) ? "Above baseline-new" : "Below baseline-new",
          "Percent-to-new: " + Math.round((cfg.pctToNew||0)*100) + "%",
          cfg.capAllTerms ? "Guardrails: max only" : "Guardrails off"
        ])}
      </div>`);
  }
}


  // STEP 1: split run paths
  function canRun(){
    if(!mappedRows?.length){ alert("Upload & confirm mapping first."); return false; }
    if(window.applySeasonalityFromUI && !window.applySeasonalityFromUI()) return false;
    return true;
  }
  function computeState(){ if (typeof window._syncBandsFromTarget === 'function') window._syncBandsFromTarget(); const cfg = readCfg(); const tState = computeTrending(mappedRows); return {cfg,tState}; }

  $("runNew").addEventListener("click",()=>{
    if(!canRun()) return;
    $("flagList").innerHTML="";
    resetNewBuffers();
    renderSeasonality(mappedRows, __seasonalityNewRows);
    const {cfg,tState} = computeState();
    const fpPts = collectNewFloorplanPoints(cfg, mappedRows, tState);
    renderNewLease(cfg,mappedRows,tState);
    // Also render Renewals so the tab is ready without manual refresh
    try{
      resetRenewBuffers();
      renderSeasonality(mappedRows, __seasonalityRenewRows);
      renderRenewals(cfg, mappedRows, tState);
    }catch(e){}
    setBadge("nlBadge","new", (__newPricingRows.length>0? (__newPricingRows.length-1):0));
    addHistory("new", cfg, tState, (__newPricingRows.length>0? (__newPricingRows.length-1):0), fpPts);
    enableExportNew(true);
    if (Array.isArray(window.mappedRows) && typeof window.__updateStatusFromMappedRows==='function'){
      window.__updateStatusFromMappedRows(window.mappedRows);
    }
  });

  $("runRenew").addEventListener("click",()=>{
    if(!canRun()) return;
    $("flagList").innerHTML="";
    resetRenewBuffers();
    renderSeasonality(mappedRows, __seasonalityRenewRows);
    const {cfg,tState} = computeState();
    renderRenewals(cfg,mappedRows,tState);
    setBadge("renBadge","renew", (__renewalsRows.length>0? (__renewalsRows.length-1):0));
    addHistory("renew", cfg, tState, (__renewalsRows.length>0? (__renewalsRows.length-1):0));
    enableExportRenew(true);
    if (Array.isArray(window.mappedRows) && typeof window.__updateStatusFromMappedRows==='function'){
      window.__updateStatusFromMappedRows(window.mappedRows);
    }
  });

  $("exportNew").addEventListener("click", exportNew);
  $("exportRenew").addEventListener("click", exportRenew);

})();

// --- Local History (scaffold) ---
let __history = []; // keep last 100 runs

function snapshotCfg(cfg){
  try{
    // shallow copy only of keys we care about
    const keys = ["comfortTarget","bandLow","bandHigh","convSensitivity","priceResponse","fpSensitivity","seasonalityCurve",
                  "allowDecAbove","capAllTerms","pctToNew","renMin","renMax","renAboveMin","renAboveMax",
                  "renTerms","nlTerms","changeCadence"];
    const out = {};
    keys.forEach(k => out[k] = Array.isArray(cfg[k]) ? [...cfg[k]] : cfg[k]);
    return out;
  }catch(e){ return {}; }
}

function addHistory(kind, cfg, tState, rowCount, fpPoints){
  const item = {
    ts: new Date().toISOString(),
    kind: kind,                    // "new" | "renew"
    rows: rowCount|0,
    cfg: snapshotCfg(cfg),
    t: {
      comm: (typeof tState?.tComm === "number" ? Math.round(tState.tComm*1000)/1000 : null),
      fps: tState && tState.tFP ? Object.keys(tState.tFP).length : null
    }
  };
  if(kind === 'new' && Array.isArray(fpPoints)) item.fpPoints = fpPoints;
  __history.unshift(item);
  if(__history.length > 100) __history = __history.slice(0,100);
  // Placeholder: future UI rendering goes here.
}

window.getHistory = () => __history.slice(); // read-only copy
window.clearHistory = () => { __history = []; };


